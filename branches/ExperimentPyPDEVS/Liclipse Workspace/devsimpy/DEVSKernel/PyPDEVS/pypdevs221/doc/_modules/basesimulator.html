

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>basesimulator &mdash; PythonPDEVS 2.2.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="PythonPDEVS 2.2.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">PythonPDEVS 2.2.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for basesimulator</h1><div class="highlight"><pre>
<span class="c"># -*- coding: Latin-1 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Actual simulation kernel</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">solver</span> <span class="kn">import</span> <span class="n">Solver</span>

<span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">messageScheduler</span> <span class="kn">import</span> <span class="n">MessageScheduler</span>
<span class="kn">from</span> <span class="nn">message</span> <span class="kn">import</span> <span class="n">NetworkMessage</span>
<span class="kn">from</span> <span class="nn">DEVS</span> <span class="kn">import</span> <span class="n">RootDEVS</span><span class="p">,</span> <span class="n">CoupledDEVS</span><span class="p">,</span> <span class="n">AtomicDEVS</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">logger</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">tracers</span> <span class="kn">import</span> <span class="n">Tracers</span>
<span class="kn">from</span> <span class="nn">activityVisualisation</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">Queue</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">queue</span> <span class="kn">as</span> <span class="nn">Queue</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<div class="viewcode-block" id="BaseSimulator"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator">[docs]</a><span class="k">class</span> <span class="nc">BaseSimulator</span><span class="p">(</span><span class="n">Solver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The BaseSimulator class, this is the actual simulation kernel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BaseSimulator.__init__"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">server</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        :param name: the name of the kernel</span>
<span class="sd">        :param model: the model to initialise the kernel with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Solver</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inits</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">server</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">Tracers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporaryIrreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sendmsgcounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">realtime</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useDSDEVS</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activityTracking</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memoization</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totalActivities</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msgSent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msgRecv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlockRequest</span> <span class="o">=</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.resetSimulation"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.resetSimulation">[docs]</a>    <span class="k">def</span> <span class="nf">resetSimulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the simulation kernel to the saved version; can only be invoked after a previous simulation run.</span>

<span class="sd">        :param scheduler: the scheduler to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">model_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inits</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">Tracers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporaryIrreversible</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sendmsgcounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">realtime</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">saveAndProcessModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pickledModel</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retdict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For pickling</span>

<span class="sd">        :param retdict: dictionary containing the attributes to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inits</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">retdict</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">retdict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For pickling</span>

<span class="sd">        :returns: dictionary containing attributes and their values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;instancemethod&quot;</span><span class="p">,</span> <span class="s">&quot;lock&quot;</span><span class="p">,</span> <span class="s">&quot;_Event&quot;</span><span class="p">,</span> <span class="s">&quot;Thread&quot;</span><span class="p">,</span> <span class="s">&quot;method-wrapper&quot;</span><span class="p">,</span> <span class="s">&quot;builtin_function_or_method&quot;</span><span class="p">]:</span>
                <span class="c"># unpicklable, so don&#39;t copy it</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;tracers&quot;</span><span class="p">:</span>
                <span class="n">retdict</span><span class="p">[</span><span class="s">&quot;tracers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">tracers_init</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;inputScheduler&quot;</span><span class="p">,</span> <span class="s">&quot;inqueue&quot;</span><span class="p">,</span> <span class="s">&quot;actions&quot;</span><span class="p">,</span> <span class="s">&quot;server&quot;</span><span class="p">,</span> <span class="s">&quot;transitioning&quot;</span><span class="p">,</span> <span class="s">&quot;Vchange&quot;</span><span class="p">,</span> <span class="s">&quot;V&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;__&quot;</span><span class="p">)):</span>
                <span class="n">retdict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="c"># ELSE</span>
                <span class="c"># wastefull to pickle, since they contain information about the future that will</span>
                <span class="c">#  certainly be replicated when restoring from checkpoint</span>
        <span class="k">return</span> <span class="n">retdict</span>

<div class="viewcode-block" id="BaseSimulator.inits"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.inits">[docs]</a>    <span class="k">def</span> <span class="nf">inits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise the simulation kernel, this is split up from the constructor to</span>
<span class="sd">        make it possible to reset the kernel without reconstructing the kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finishCheck</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termination_time_check</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termination_condition</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">blockOutgoing</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relocationPending</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Mattern&#39;s GVT algorithm</span>
        <span class="c"># 0 = white1</span>
        <span class="c"># 1 = red1</span>
        <span class="c"># 2 = white2</span>
        <span class="c"># 3 = red2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{}]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">controlmsg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span> <span class="o">=</span> <span class="n">MessageScheduler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="c"># Acquire the lock ASAP, to prevent simulation during/after shutdown</span>
        <span class="c"># it has to be released as soon as the simulation is commenced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waitForGVT</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span> <span class="o">=</span> <span class="p">[</span><span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">(),</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simFinish</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getProxy"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getProxy">[docs]</a>    <span class="k">def</span> <span class="nf">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a proxy to the specified rank.</span>

<span class="sd">        Method will simply forward the request to its server object.</span>

<span class="sd">        :param rank: the rank to return a proxy to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getSelfProxy"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getSelfProxy">[docs]</a>    <span class="k">def</span> <span class="nf">getSelfProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a proxy to ourself.</span>

<span class="sd">        This method is useful in case the underlying code has no idea on which node it is running and it simply wants to contact its kernel.</span>
<span class="sd">        It also differs from simply calling the code on the object of the kernel, as this provides a wrapper for asynchronous local invocation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setTerminationTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setTerminationTime">[docs]</a>    <span class="k">def</span> <span class="nf">setTerminationTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the time at which simulation should stop, setting this will override</span>
<span class="sd">        the local simulation condition.</span>

<span class="sd">        :param time: the time at which the simulation should stop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="c"># Set it in case the kernel was already stopped and an invalidation happened</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.sendModel"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.sendModel">[docs]</a>    <span class="k">def</span> <span class="nf">sendModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">,</span> <span class="n">schedulerType</span><span class="p">,</span> <span class="n">flattened</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Send a model to this simulation kernel, as this one will be simulated</span>

<span class="sd">        :param model: the model to set</span>
<span class="sd">        :param model_ids: list containing all models in order of their model_ids</span>
<span class="sd">        :param schedulerType: string representation of the scheduler to use</span>
<span class="sd">        :param flattened: whether or not the model had its ports decoupled from the models to allow pickling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span> <span class="o">=</span> <span class="n">flattened</span>
        <span class="k">if</span> <span class="n">flattened</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">unflattenConnections</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span> <span class="o">=</span> <span class="n">model_ids</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">)</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">local</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">remotes</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">atomic</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">location</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="c"># Model is simulated here</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomic</span>
                <span class="n">local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atomic</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">location</span>
                <span class="n">remotes</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">local</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">CoupledDEVS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">RootDEVS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">componentSet</span><span class="p">,</span> <span class="n">schedulerType</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">AtomicDEVS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">RootDEVS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local</span><span class="p">,</span> <span class="p">[</span><span class="n">model</span><span class="p">],</span> <span class="n">schedulerType</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">activities</span> <span class="o">=</span> <span class="p">{}</span>
</div>
<div class="viewcode-block" id="BaseSimulator.migrateTo"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.migrateTo">[docs]</a>    <span class="k">def</span> <span class="nf">migrateTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Migrate all models to a new destination</span>

<span class="sd">        :param destination: destination of all models specified hereafter</span>
<span class="sd">        :param model_ids: iterable containing all models to migrate simultaneously</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Assumes that the simlock is already acquired</span>
        <span class="c"># Make sure that the model that we are migrating is local here</span>
        <span class="c">#assert info(&quot;Migrating &quot; + str(model_ids) + &quot; to &quot; + str(destination))</span>
        <span class="n">models</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Cannot migrate model that is not local to the source!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">relocatable</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Model </span><span class="si">%s</span><span class="s"> was marked as fixed and is therefore not allowed to be relocated&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">getModelFullName</span><span class="p">())</span>
            <span class="n">models</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">])</span>
        <span class="n">destination</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">destination</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="c"># Model is already there...</span>
            <span class="k">return</span>
        <span class="c">#assert info(&quot;Migration approved of %s from node %d to node %d&quot; % (model_ids, self.name, destination))</span>

        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="c"># All models are gone here, so remove them from the scheduler</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">unschedule</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">destination</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">notifyMigration</span><span class="p">(</span><span class="n">model_ids</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>

        <span class="n">remote</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
        <span class="c"># NOTE Due to the revertions, the outputQueue will be completely empty because:</span>
        <span class="c">#        - messages before the GVT are cleaned up due to fossil collection</span>
        <span class="c">#        - messages after the GVT are cleaned up due to the revertion that sends anti-messages</span>
        <span class="c"># Furthermore, the state vector will be as small as possible to reduce the amount of data that has to be transferred</span>
        <span class="c"># The inputqueue requires some small processing: all future incomming messages for the model that gets migrated</span>
        <span class="c"># needs to be found. The processed messages list should be empty, with the following reason as the outputQueue.</span>
        <span class="n">remote</span><span class="o">.</span><span class="n">messageTransfer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">model_ids</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="c"># No need to ask the new node whether or not there are specific nodes that also have to be informed</span>
            <span class="n">remote</span><span class="o">.</span><span class="n">activateModel</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">model_id</span><span class="p">,</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">timeLast</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">timeNext</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">state</span><span class="p">))</span>
            <span class="c"># Delete our representation of the model</span>
            <span class="n">model</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">model</span><span class="o">.</span><span class="n">oldStates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">model_id</span><span class="p">]</span>

        <span class="c"># Remove the model from the componentSet of the RootDEVS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">componentSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">componentSet</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">models</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">model_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">destination</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">destination</span>

        <span class="c"># Now update the timeNext and timeLast values here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setTimeNext</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.notifyMigration"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.notifyMigration">[docs]</a>    <span class="k">def</span> <span class="nf">notifyMigration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notify the migration of a model_id to a new destination</span>

<span class="sd">        :param model_ids: the model_ids that gets moved</span>
<span class="sd">        :param destination: the node location that now hosts the model_id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">destination</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="c"># No need to notify ourselves, simply here for safety as it shouldn&#39;t be called</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">destination</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">destination</span>
</div>
<div class="viewcode-block" id="BaseSimulator.requestMigrationLock"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.requestMigrationLock">[docs]</a>    <span class="k">def</span> <span class="nf">requestMigrationLock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Request this kernel to lock itself ASAP to allow a relocation to happen. This will invoke the *notifyLocked* method on the controller as soon as locking succeeded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relocationPending</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">notifyLocked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.migrationUnlock"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.migrationUnlock">[docs]</a>    <span class="k">def</span> <span class="nf">migrationUnlock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unlocks the simulation lock remotely.</span>

<span class="sd">        .. warning:: do not use this function, unless you fully understand what you are doing!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

        <span class="c">#TODO this might cause problems...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relocationPending</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.activateModel"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.activateModel">[docs]</a>    <span class="k">def</span> <span class="nf">activateModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">currentState</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate the model at this kernel, thus allowing the kernel to use (and schedule) this model. </span>
<span class="sd">        Note that a revert to the GVT has to happen before calling this function, since the old_states </span>
<span class="sd">        are not transferred and thus reverting is impossible.</span>

<span class="sd">        :param model_id: the id of the model that has to be activated</span>
<span class="sd">        :param currentState: the current state of the model that gets migrated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
        <span class="n">old_location</span> <span class="o">=</span> <span class="n">new_model</span><span class="o">.</span><span class="n">location</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">componentSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_model</span><span class="o">.</span><span class="n">model_id</span><span class="p">)</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">timeLast</span> <span class="o">=</span> <span class="n">currentState</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">timeNext</span> <span class="o">=</span> <span class="n">currentState</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">currentState</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">new_model</span><span class="o">.</span><span class="n">oldStates</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state_saver</span><span class="p">(</span><span class="n">new_model</span><span class="o">.</span><span class="n">timeLast</span><span class="p">,</span> <span class="n">new_model</span><span class="o">.</span><span class="n">timeNext</span><span class="p">,</span> <span class="n">new_model</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">{},</span> <span class="mf">0.0</span><span class="p">)]</span>
        <span class="c"># It is a new model, so add it to the scheduler too</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">new_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setTimeNext</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
</div>
<div class="viewcode-block" id="BaseSimulator.messageTransfer"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.messageTransfer">[docs]</a>    <span class="k">def</span> <span class="nf">messageTransfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extraction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfer the messages during a model transfer</span>

<span class="sd">        :param extraction: the extraction generated by the *messageScheduler*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">extraction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.notifySend"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.notifySend">[docs]</a>    <span class="k">def</span> <span class="nf">notifySend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notify the simulation kernel of the sending of a message. Needed for</span>
<span class="sd">        GVT calculation.</span>

<span class="sd">        :param destination: the name of the simulation kernel that will receive the sent message</span>
<span class="sd">        :param timestamp: simulation time at which the message is sent</span>
<span class="sd">        :param color: color of the message being sent (for Mattern&#39;s algorithm)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msgSent</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">color</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># red1 or red2 doesn&#39;t matter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.notifyReceive"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.notifyReceive">[docs]</a>    <span class="k">def</span> <span class="nf">notifyReceive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notify the simulation kernel of the receiving of a message. Needed for</span>
<span class="sd">        GVT calculation.</span>

<span class="sd">        :param color: the color of the received message (for Mattern&#39;s algorithm)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#assert debug(&quot;Received message with color: &quot; + str(color))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msgRecv</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">color</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.waitUntilOK"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.waitUntilOK">[docs]</a>    <span class="k">def</span> <span class="nf">waitUntilOK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns as soon as all messages to this simulation kernel are received.</span>
<span class="sd">        Needed due to Mattern&#39;s algorithm. Uses events to prevent busy looping.</span>

<span class="sd">        :param vector: the vector number to wait for. Should be 0 for colors 0 and 1, should be 1 for colors 2 and 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">vector</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlmsg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="c"># Use an event to prevent busy looping</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span><span class="p">[</span><span class="n">vector</span><span class="p">]</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vchange</span><span class="p">[</span><span class="n">vector</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="c"># Free the lock</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.receiveControl"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.receiveControl">[docs]</a>    <span class="k">def</span> <span class="nf">receiveControl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Receive a GVT control message and process it. Method will block until the GVT is actually found, so make this an asynchronous call, or run it on a seperate thread.</span>

<span class="sd">        This code implements Mattern&#39;s algorithm with a slight modification: it uses 4 different colours to distinguish two subsequent runs. Furthermore, it always requires 2 complete passes before a GVT is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">controlmsg</span> <span class="o">=</span> <span class="n">msg</span>
        <span class="n">m_clock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlmsg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m_send</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlmsg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">controlmsg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c">#print(&quot;[%s] RECV %s %s %s&quot; % (self.name, m_clock, m_send, count))</span>

        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># We are currently white, about to turn red</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="c"># The controller received the message that went around completely</span>
                <span class="c"># The count != check is needed to distinguish between init and finish</span>
                <span class="c"># So we are finished now, don&#39;t update the color here!!</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allZeroDict</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;GVT bug detected&quot;</span><span class="p">)</span>
                <span class="c"># Perform some rounding to prevent slight deviations due to floating point errors</span>
                <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>
                <span class="n">GVT</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m_clock</span><span class="p">,</span> <span class="n">m_send</span><span class="p">))</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Found GVT &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">GVT</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">GVT</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;GVT is decreasing&quot;</span><span class="p">)</span>
                <span class="c"># Do this with a proxy to make it async</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">setGVT</span><span class="p">(</span><span class="n">GVT</span><span class="p">,</span> <span class="p">[],</span> <span class="bp">self</span><span class="o">.</span><span class="n">relocator</span><span class="o">.</span><span class="n">useLastStateOnly</span><span class="p">())</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Either at the controller at init</span>
                <span class="c">#  or just a normal node that is about to turn red</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
                    <span class="n">addDict</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c"># Time in the first iteration doesn&#39;t matter,</span>
                <span class="c"># as we will certainly do a second run</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">m_send</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span><span class="p">),</span> <span class="n">count</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nextLP</span><span class="o">.</span><span class="n">receiveControl</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c"># We are currently red, about to turn white</span>
            <span class="c"># First wait for all messages in the medium</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">waitUntilOK</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">addDict</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c"># Now our V is ok, so clear it</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>

            <span class="n">localtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
            <span class="n">ntime</span> <span class="o">=</span> <span class="n">localtime</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">m_clock</span><span class="p">,</span> <span class="n">localtime</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="n">ntime</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">m_send</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span><span class="p">),</span> <span class="n">count</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nextLP</span><span class="o">.</span><span class="n">receiveControl</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setIrreversible"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setIrreversible">[docs]</a>    <span class="k">def</span> <span class="nf">setIrreversible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark this node as **temporary** irreversible, meaning that it can simply be made reversible later on. </span>
<span class="sd">        This can be used when all nodes are ran at a single node due to relocation, though future relocations might again move some nodes away.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporaryIrreversible</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activityTracking</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseSimulator.unsetIrreversible"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.unsetIrreversible">[docs]</a>    <span class="k">def</span> <span class="nf">unsetIrreversible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unmark this node as **temporary** irreversible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporaryIrreversible</span> <span class="o">=</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setGVT"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setGVT">[docs]</a>    <span class="k">def</span> <span class="nf">setGVT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GVT</span><span class="p">,</span> <span class="n">activities</span><span class="p">,</span> <span class="n">lastStateOnly</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the GVT of this simulation kernel. This value should not be smaller than</span>
<span class="sd">        the current GVT (this would be impossible for a correct GVT calculation). Also</span>
<span class="sd">        cleans up the input, output and state buffers used due to time-warp.</span>
<span class="sd">        Furthermore, it also processes all messages scheduled before the GVT.</span>

<span class="sd">        :param GVT: the desired GVT</span>
<span class="sd">        :param activities: the activities of all seperate nodes as a list</span>
<span class="sd">        :param lastStateOnly: whether or not all states should be considered or only the last</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># GVT is just a time, it does not contain an age field!</span>
        <span class="c">#assert debug(&quot;Got setGVT&quot;)</span>
        <span class="k">if</span> <span class="n">GVT</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;GVT cannot decrease from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">GVT</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">GVT</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
            <span class="c"># The same, so don&#39;t do the batched fossil collection</span>
            <span class="c"># This will ALWAYS happen at the controller first, as this is the one that gets called with the GVT update first</span>
            <span class="c">#   if the value should change, it will do a complete round and finally set the variable</span>
            <span class="c">#   if the value stays the same, we can stop immediately</span>
            <span class="c">#assert info(&quot;Set GVT to %s&quot; % GVT)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialAllocator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">GVT</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialAllocator</span><span class="o">.</span><span class="n">getTerminationTime</span><span class="p">():</span>
                    <span class="c"># The initial allocator period is over, so switch to normal simulation</span>
                    <span class="n">relocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInitialAllocations</span><span class="p">()</span>
                    <span class="c"># Possibly, the locations are altered, so reset everything</span>
                    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">componentSet</span><span class="p">:</span>
                        <span class="n">model</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">atomicOutputGeneration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomicOutputGeneration_backup</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">performRelocationsInit</span><span class="p">(</span><span class="n">relocs</span><span class="p">)</span>
                <span class="c"># Clear activities for now, as we don&#39;t want activity relocation medling in our affairs</span>
                <span class="n">activities</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">activities</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldGVT</span> <span class="o">==</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">oldGVT</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldGVT</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldGVT</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;activity-log&quot;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">GVT</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldGVT</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">oldGVT</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">activities</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">horizon</span><span class="p">))</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">findAndPerformRelocations</span><span class="p">(</span><span class="n">GVT</span><span class="p">,</span> <span class="n">activities</span><span class="p">,</span> <span class="n">horizon</span><span class="p">)</span>
            <span class="c"># Otherwise: there was no pass in the GVT ring, indicating that no GVT progress was made</span>
            <span class="c"># This also indicates that the activities will NOT be reset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GVTdone</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">simlockRequest</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simlockRequest</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c">#assert debug(&quot;Set GVT to &quot; + str(GVT))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oldGVT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span> <span class="o">=</span> <span class="n">GVT</span>

            <span class="n">nqueue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">cleanup</span><span class="p">((</span><span class="n">GVT</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">performActions</span><span class="p">(</span><span class="n">GVT</span><span class="p">)</span>

            <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">GVT</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span><span class="p">[</span><span class="n">index</span><span class="p">:]</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">activities</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setGVT</span><span class="p">(</span><span class="n">GVT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">,</span> <span class="n">lastStateOnly</span><span class="p">)</span>
            <span class="n">addDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totalActivities</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporaryIrreversible</span><span class="p">:</span>
                <span class="c">#print(&quot;Setting new state for %s models&quot; % len(self.model.componentSet))</span>
                <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">componentSet</span><span class="p">:</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">oldStates</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state_saver</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">timeLast</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">timeNext</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalActivities</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">model_id</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">totalActivities</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="c"># Make a checkpoint too</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpointCounter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpointFreq</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpointCounter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpointCounter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Move the pending activities</span>
        <span class="k">if</span> <span class="n">lastStateOnly</span><span class="p">:</span>
            <span class="n">activitySum</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">activitySum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">activities</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">activitySum</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nextLP</span><span class="o">.</span><span class="n">setGVT</span><span class="p">(</span><span class="n">GVT</span><span class="p">,</span> <span class="n">activities</span><span class="p">,</span> <span class="n">lastStateOnly</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.revert"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.revert">[docs]</a>    <span class="k">def</span> <span class="nf">revert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Revert the current simulation kernel to the specified time. All messages</span>
<span class="sd">        sent after this time will be invalidated, all states produced after this</span>
<span class="sd">        time will be removed.</span>

<span class="sd">        :param time: the desired time for revertion.</span>

<span class="sd">        .. note:: Clearly, this time should be &gt;= the current GVT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Don&#39;t #assert that it is not irreversible, as an irreversible component could theoretically still be reverted, but this MUST be to a state when it was not yet irreversible</span>
        <span class="c"># Reverting the complete LP</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Reverting to time </span><span class="si">%f</span><span class="s">, before the GVT (</span><span class="si">%f</span><span class="s">)!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">))</span>
        <span class="c">#assert debug(&quot;Removing actions from time &quot; + str(time))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c">#assert debug(&quot;Revert to time &quot; + str(time) + &quot;, clock = &quot; + str(self.clock))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doSomeTracing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">removeActions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="c"># Also revert the input message scheduler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="c"># Now revert all local models</span>
        <span class="n">controllerRevert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memoization</span><span class="p">)</span>
        <span class="c">#assert debug(&quot;Reverted all models&quot;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="n">time</span>

        <span class="c"># Invalidate all output messages after or at time</span>
        <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">unschedules</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unschedules_mintime</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span><span class="p">):</span>
            <span class="c"># Do not invalidate messages at this time itself, as they are processed in this time step and not generated in this timestep</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;</span> <span class="n">time</span><span class="p">:</span>
                <span class="n">model_id</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">destination</span>
                <span class="n">unschedules_mintime</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unschedules_mintime</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">value</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
                <span class="n">unschedules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c">#assert debug(&quot;NOT invalidating &quot; + str(value.uuid))</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span><span class="p">[:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blockOutgoing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blockOutgoing</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Don&#39;t need the Vlock here, as we already have it</span>
        <span class="k">for</span> <span class="n">model_id</span> <span class="ow">in</span> <span class="n">unschedules</span><span class="p">:</span>
            <span class="n">dest_kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dest_kernel</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Revertion due to relocation to self... This is impossible!&quot;</span><span class="p">)</span>
            <span class="n">mintime</span> <span class="o">=</span> <span class="n">unschedules_mintime</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
            <span class="c"># Assume we have the simlock already</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="n">dest_kernel</span><span class="p">,</span> <span class="n">mintime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">dest_kernel</span><span class="p">)</span><span class="o">.</span><span class="n">receiveAntiMessages</span><span class="p">(</span><span class="n">mintime</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">unschedules</span><span class="p">[</span><span class="n">model_id</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

        <span class="c"># Controller has read one of the reverted states, so force a rollback there</span>
        <span class="k">if</span> <span class="n">controllerRevert</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">receiveAntiMessages</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.send"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.send">[docs]</a>    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare a message to be sent remotely and do the actual sending too.</span>

<span class="sd">        :param model_id: the id of the model that has to receive the message</span>
<span class="sd">        :param timestamp: timestamp of the message</span>
<span class="sd">        :param content: content of the message being sent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blockOutgoing</span> <span class="o">==</span> <span class="n">timestamp</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span><span class="p">):</span>
            <span class="c"># If the model was just reverted, we don&#39;t need to sent out these </span>
            <span class="c"># messages because they are already in the receivers queues.</span>
            <span class="c">#assert debug(&quot;Not sending message &quot; + str(timestamp))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Sending message (</span><span class="si">%s</span><span class="s">) from before the GVT (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">remote_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
        <span class="c"># NOTE the Vlock is already acquired by the sender</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">NetworkMessage</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">genUUID</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">model_id</span><span class="p">)</span>
        <span class="c"># The message should be saved, though it should not be a copy. This is because the middleware will make</span>
        <span class="c"># a copy itself, making this old message unused. Furthermore, the receiver will always create a copy</span>
        <span class="c"># of the message to be safe, making a copy at the source unnecessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Assume we have the simlock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="n">remote_location</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">remote_location</span><span class="p">)</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.receive"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.receive">[docs]</a>    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make the kernel receive the provided message.</span>

<span class="sd">        The method will return as soon as possible to prevent a big number of pending messages.</span>
<span class="sd">        Furthermore, acquiring the locks here would be impractical since we only process all incomming messages one at a time.</span>

<span class="sd">        :param msg: a NetworkMessage to process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># NOTE ports could change at run-time, though this is not a problem in distributed simulation!</span>
        <span class="c"># NOTE no need for locking, as all methods of a deque object is atomic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.processIncommingMessages"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.processIncommingMessages">[docs]</a>    <span class="k">def</span> <span class="nf">processIncommingMessages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process all incomming messages and return.</span>

<span class="sd">        This is part of the main simulation loop instead of being part of the message receive method, as we require the simlock for this. Acquiring the simlock elsewhere might take some time!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">dest_model</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">destination</span>
            <span class="k">if</span> <span class="n">dest_model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span><span class="p">:</span>
                <span class="c"># NOTE do it this way to make sure that anti message properties are conserved</span>
                <span class="c">#      furthermore, it prevents the message from being invalidated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">dest_model</span><span class="p">]</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span>
                <span class="c"># No need to reencode the data, as it was still encoded</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c">#assert debug(&quot;Processing external msg: &quot; + str(msg))</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">dest_model</span><span class="p">]</span>
            <span class="n">msg</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="p">{</span><span class="n">model</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">entry</span><span class="p">]:</span> <span class="n">msg</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">content</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">:</span>
                <span class="c"># Timestamp is before the prevtime</span>
                <span class="c"># so set the prevtime back in the past</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span><span class="p">:</span>
                <span class="c"># The prevtime is irrelevant, as we have finished simulation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

            <span class="c"># Now the message is an &#39;ordinary&#39; message, just schedule it for processing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.receiveAntiMessages"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.receiveAntiMessages">[docs]</a>    <span class="k">def</span> <span class="nf">receiveAntiMessages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mintime</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">uuids</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process a (possibly huge) batch of anti messages for the same model</span>

<span class="sd">        :param mintime: the lowest timestamp of all messages being cancelled</span>
<span class="sd">        :param model_id: the model_id of the receiving model whose messages need to be negated, None to indicate a general rollback</span>
<span class="sd">        :param uuids: list of all uuids to cancel</span>
<span class="sd">        :param color: color for Mattern&#39;s algorithm</span>

<span class="sd">        .. note:: the *model_id* is only required to check whether or not the model is still local to us</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Important that this function is called oneway, as it can be called in such a way that it deadlocks otherwise</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">model_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">local_model_ids</span> <span class="ow">and</span> <span class="n">model_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">])</span><span class="o">.</span><span class="n">receiveAntiMessages</span><span class="p">(</span><span class="n">mintime</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">uuids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">notifySend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">],</span> <span class="n">mintime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">if</span> <span class="n">mintime</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">:</span>
                        <span class="c"># Timestamp is before the prevtime</span>
                        <span class="c"># so set the prevtime back in the past</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">mintime</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span><span class="p">:</span>
                        <span class="c"># The prevtime is irrelevant, as we have finished simulation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="n">mintime</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">notifyReceive</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">model_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">massUnschedule</span><span class="p">(</span><span class="n">uuids</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.check"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.check">[docs]</a>    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks wheter or not simulation should still continue. This will either</span>
<span class="sd">        call the global time termination check, or the local state termination</span>
<span class="sd">        check, depending on configuration.</span>

<span class="sd">        Using the global time termination check is a lot FASTER and should be used</span>
<span class="sd">        if possible.</span>

<span class="sd">        :returns: bool -- whether or not to stop simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Return True = stop simulation</span>
        <span class="c"># Return False = continue simulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="c"># Max loop checks</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Maximal number of 0 timeAdvance loops detected&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time_check</span><span class="p">:</span>
            <span class="c"># Finish at the termination time</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">readFirst</span><span class="p">()</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c"># No message waiting to be processed, so finished</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Use a termination condition</span>
            <span class="c"># This code is only ran at the controller, as this is the only one with a termination condition</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_condition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_model</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finishAtTime</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finishAtTime</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finish_sent</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseSimulator.finishAtTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.finishAtTime">[docs]</a>    <span class="k">def</span> <span class="nf">finishAtTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clock</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Signal this kernel that it may stop at the provided time</span>

<span class="sd">        :param clock: the time to stop at</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernels</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">setTerminationTime</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.massDelayedActions"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.massDelayedActions">[docs]</a>    <span class="k">def</span> <span class="nf">massDelayedActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">msgs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the delayedAction function multiple times in succession.</span>

<span class="sd">        Mainly implemented to reduce the number of round trips when tracing.</span>

<span class="sd">        :param time: the time at which the action should happen</span>
<span class="sd">        :param msgs: list containing elements of the form (model_id, action)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span> <span class="ow">in</span> <span class="n">msgs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delayedAction</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.delayedAction"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.delayedAction">[docs]</a>    <span class="k">def</span> <span class="nf">delayedAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform an irreversible action (I/O, prints, global messages, ...). All</span>
<span class="sd">        these actions will be performed in the order they should be generated</span>
<span class="sd">        in a non-distributed simulation. All these messages might be reverted in</span>
<span class="sd">        case a revertion is performed by the calling model.</span>

<span class="sd">        :param time: the simulation time at which this command was requested</span>
<span class="sd">        :param model_id: the model_id of the model that requested this command</span>
<span class="sd">        :param action: the actual command to be executed as soon as it is safe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#assert debug(&quot;Adding action for time &quot; + str(time) + &quot;, GVT = &quot; + str(self.GVT))</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Cannot execute action before the GVT! (time = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, GVT = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">performActions</span><span class="p">()</span>
        <span class="c"># An append is an atomic action, though we need to lock it as other operations on it arent&#39; atomic</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">action</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="BaseSimulator.removeActions"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.removeActions">[docs]</a>    <span class="k">def</span> <span class="nf">removeActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_ids</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all actions specified by a model, starting from a specified time.</span>
<span class="sd">        This function should be called when the model is reverted and its actions</span>
<span class="sd">        have to be undone</span>

<span class="sd">        :param model_ids: the model_ids of all reverted models</span>
<span class="sd">        :param time: time up to which to remove all actions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Cannot remove action before the GVT! (time = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, GVT = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span>
        <span class="c">#assert debug(&quot;Removing actions for time &quot; + str(time) + &quot; and for ids &quot; + str(model_ids))</span>
        <span class="c"># Actions are unsorted, so we have to go through the complete list</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">model_ids</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="p">))]</span>
</div>
<div class="viewcode-block" id="BaseSimulator.performActions"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.performActions">[docs]</a>    <span class="k">def</span> <span class="nf">performActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gvt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform all irreversible actions up to the provided time.</span>
<span class="sd">        If time is not specified, all queued actions will be executed (in case simulation is finished)</span>

<span class="sd">        :param gvt: the time up to which all actions should be executed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gvt</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># But crop of to the termination_time as we might have simulated slightly too long</span>
            <span class="n">gvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">EPSILON</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionlock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gvt</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
                <span class="c"># Only take the relevant part to sort, this will decrease complexity</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">remainder</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">gvt</span><span class="p">:</span>
                        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">remainder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span>
                <span class="n">remainder</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="n">remainder</span>
            <span class="c"># Release the lock ASAP, to allow other actions to be performed</span>

        <span class="c"># Sort on time first, then on MESSAGE, not on model</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

        <span class="c"># Now execute each action in order</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="k">exec</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setGlobals"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setGlobals">[docs]</a>    <span class="k">def</span> <span class="nf">setGlobals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">loglevel</span><span class="p">,</span> <span class="n">checkpointfrequency</span><span class="p">,</span> <span class="n">checkpointname</span><span class="p">,</span> <span class="n">statesaver</span><span class="p">,</span> <span class="n">kernels</span><span class="p">,</span> <span class="n">msgCopy</span><span class="p">,</span> <span class="n">memoization</span><span class="p">,</span> <span class="n">tracers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure all &#39;global&#39; variables for this kernel</span>

<span class="sd">        :param address: address of the syslog server</span>
<span class="sd">        :param loglevel: level of logging library</span>
<span class="sd">        :param checkpointfrequency: frequency at which checkpoints should be made</span>
<span class="sd">        :param checkpointname: name of the checkpoint to save</span>
<span class="sd">        :param statesaver: statesaving method</span>
<span class="sd">        :param kernels: number of simulation kernels in total</span>
<span class="sd">        :param msgcopy: message copy method</span>
<span class="sd">        :param memoization: use memoization or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span> <span class="o">=</span> <span class="n">Tracers</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tracer</span> <span class="ow">in</span> <span class="n">tracers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">registerTracer</span><span class="p">(</span><span class="n">tracer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">server</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doSomeTracing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">hasTracers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglevel</span> <span class="o">=</span> <span class="n">loglevel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernels</span> <span class="o">=</span> <span class="n">kernels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nextLP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">kernels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernels</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="kn">from</span> <span class="nn">statesavers</span> <span class="kn">import</span> <span class="n">DeepCopyState</span><span class="p">,</span> <span class="n">PickleZeroState</span><span class="p">,</span> <span class="n">PickleHighestState</span><span class="p">,</span> <span class="n">CopyState</span><span class="p">,</span> <span class="n">AssignState</span><span class="p">,</span> <span class="n">CustomState</span><span class="p">,</span> <span class="n">MarshalState</span>
        <span class="n">state_saving_options</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">DeepCopyState</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">PickleZeroState</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">PickleHighestState</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">CopyState</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">AssignState</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="n">CustomState</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="n">MarshalState</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_saver</span> <span class="o">=</span> <span class="n">state_saving_options</span><span class="p">[</span><span class="n">statesaver</span><span class="p">]</span>
        <span class="c"># Save the integer value for checkpointing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_saving</span> <span class="o">=</span> <span class="n">statesaver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msgCopy</span> <span class="o">=</span> <span class="n">msgCopy</span>
        <span class="n">setLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">loglevel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CHK_name</span> <span class="o">=</span> <span class="n">checkpointname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpointFreq</span> <span class="o">=</span> <span class="n">checkpointfrequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpointCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memoization</span> <span class="o">=</span> <span class="n">memoization</span>
</div>
<div class="viewcode-block" id="BaseSimulator.processMessage"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.processMessage">[docs]</a>    <span class="k">def</span> <span class="nf">processMessage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clock</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the first external message smaller than the clock and process them if necessary. Return the new timeNext for simulation.</span>

<span class="sd">        :param clock: timestamp of the next internal transition</span>
<span class="sd">        :returns: timestamp of the next transition, taking into account external messages</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">readFirst</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c"># No input messages</span>
            <span class="k">return</span> <span class="n">clock</span>
        <span class="k">if</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">clock</span><span class="p">:</span>
            <span class="c"># The message is sent before the timenext, so update the clock</span>
            <span class="n">clock</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">clock</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">EPSILON</span> <span class="ow">and</span> <span class="p">(</span><span class="n">clock</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">message</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">:</span>
                    <span class="n">aDEVS</span> <span class="o">=</span> <span class="n">port</span><span class="o">.</span><span class="n">hostDEVS</span>
                    <span class="n">aDEVS</span><span class="o">.</span><span class="n">myInput</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="n">port</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">[</span><span class="n">aDEVS</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">removeFirst</span><span class="p">()</span>
                <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span><span class="o">.</span><span class="n">readFirst</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c"># At the end of the scheduler, so we are done</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">clock</span>
</div>
<div class="viewcode-block" id="BaseSimulator.realtimeWait"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.realtimeWait">[docs]</a>    <span class="k">def</span> <span class="nf">realtimeWait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rt_zerotime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the waiting for input required in realtime simulation.</span>

<span class="sd">        The timeNext of the model will be updated accordingly and all messages will be routed.</span>

<span class="sd">        :param rt_zerotime: the wallclock time at which simulation started</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># NOTE a scale of 2 means that simulation will take twice as long</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">performActions</span><span class="p">()</span>
        <span class="c"># Wait for the determined period of time</span>
        <span class="n">nextSimTime</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">termination_time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtimeScale</span>
        <span class="c">#####</span>
        <span class="c"># Subtract the time that we already did our computation</span>
        <span class="n">currentRTTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">rt_zerotime</span><span class="p">)</span>
        <span class="n">waitTime</span> <span class="o">=</span> <span class="n">nextSimTime</span> <span class="o">-</span> <span class="n">currentRTTime</span>
        <span class="n">interruptSignal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threadingBackend</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">waitTime</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">interruptSignal</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Not interruption, just continue</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We were interrupted, so there is something to do</span>
            <span class="c">#inp = eventTime, eventPort, eventValue = interruptSignal</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">interruptSignal</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">portname</span><span class="p">,</span> <span class="n">eventValue</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)</span>
                <span class="n">eventPort</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">portmap</span><span class="p">[</span><span class="n">portname</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c"># Couldn&#39;t split, means we should stop</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="c"># Process the input</span>
            <span class="c">#NOTE no distinction between PDEVS and CDEVS is necessary, as CDEVS is internally handled just like PDEVS</span>
            <span class="c">#     wrappers are provided to &#39;unpack&#39; the list structure</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="n">eventPort</span><span class="p">:</span> <span class="p">[</span><span class="n">eventValue</span><span class="p">]}</span>
            <span class="n">eventPort</span><span class="o">.</span><span class="n">hostDEVS</span><span class="o">.</span><span class="n">myInput</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">[</span><span class="n">eventPort</span><span class="o">.</span><span class="n">hostDEVS</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span> <span class="o">=</span> <span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">rt_zerotime</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtimeScale</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
        </div>
<div class="viewcode-block" id="BaseSimulator.runsim"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.runsim">[docs]</a>    <span class="k">def</span> <span class="nf">runsim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run a complete simulation run. Can be run multiple times if this is required in e.g. a distributed simulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rt_zerotime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c">#TODO strip this loop</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtime</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">realtimeWait</span><span class="p">(</span><span class="n">rt_zerotime</span><span class="p">):</span>
                <span class="c"># Make implicit use of shortcut evaluation,</span>
                <span class="c"># The realtimeWait method will return True if it forces a simulation stop</span>
                <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span><span class="p">:</span>
                    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
                        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">processIncommingMessages</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

            <span class="c"># Only do the check here, after setting the next time of the simulation</span>
            
            <span class="c"># All priority threads are cleared, so obtain the simulation lock ourself</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="c"># Process all incomming messages</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span><span class="p">:</span>
                    <span class="c"># Check the external messages only if there is a possibility for them to arrive</span>
                    <span class="c"># This is a slight optimisation for local simulation</span>
                    <span class="n">tn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processMessage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span>
                <span class="k">if</span> <span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
                    <span class="c"># Always break, even if the terminiation condition/time was wrong</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtimefinished</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="n">cDEVS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
                <span class="c"># Round of the current clock time, which is necessary for revertions later on</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currentclock</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">6</span><span class="p">),</span> <span class="n">tn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentclock</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DEVSException</span><span class="p">(</span><span class="s">&quot;Runsim executes action before the GVT: </span><span class="si">%s</span><span class="s"> -- </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentclock</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">))</span>

                <span class="c"># Don&#39;t interrupt the output generation, as these nodes WILL be marked as &#39;sent&#39;</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                    <span class="n">reschedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupledOutputGeneration</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentclock</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">massAtomicTransitions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentclock</span><span class="p">)</span>
                    <span class="n">cDEVS</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">massReschedule</span><span class="p">(</span><span class="n">reschedule</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useDSDEVS</span><span class="p">:</span>
                        <span class="c"># Check for dynamic structure simulation</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">performDSDEVS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">QuickStopException</span><span class="p">:</span>
                    <span class="c"># For relocations that should interrupt the simulation algorithm</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                    <span class="k">continue</span>

                <span class="c"># Put this in a lock to prevent a possible infinite timeNext from reading the prevtime with the old value</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
                    <span class="c"># Fetch the next time of a transition</span>
                    <span class="n">cDEVS</span><span class="o">.</span><span class="n">setTimeNext</span><span class="p">()</span>
                    <span class="c"># Clear all transitioning elements</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="c"># No longer block any output messages</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">blockOutgoing</span> <span class="o">=</span> <span class="bp">None</span>

                    <span class="c"># self.clock now contains the time at which NO messages were sent</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentclock</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span>
</div>
<div class="viewcode-block" id="BaseSimulator.finishRing"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.finishRing">[docs]</a>    <span class="k">def</span> <span class="nf">finishRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msgSent</span><span class="p">,</span> <span class="n">msgRecv</span><span class="p">,</span> <span class="n">firstRun</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Go over the ring and ask each kernel whether it is OK to stop simulation</span>
<span class="sd">        or not. Uses a count to check that no messages are yet to be processed.</span>

<span class="sd">        :param msgSent: current counter for total amount of sent messages</span>
<span class="sd">        :param msgRecv: current counter for total amount of received messages</span>
<span class="sd">        :param firstRun: whether or not to forward at the controller</span>
<span class="sd">        :returns: int -- amount of messages received and sent (-1 signals running simulation)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#NOTE due to the MPI backend changing None to 0, we need to return something else, like a -1...</span>
        <span class="c"># Try to obtain the simulation lock first</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
            <span class="c"># It was already taken, so something is still working</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span><span class="o">.</span><span class="n">isSet</span><span class="p">():</span>
                <span class="c"># We should still run</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">firstRun</span><span class="p">:</span>
                <span class="c"># We are done, so return if they are equal</span>
                <span class="k">if</span> <span class="n">msgSent</span> <span class="o">==</span> <span class="n">msgRecv</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">msgSent</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Some messages are not yet received, so not correct</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># Always release the simlock when we got it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="c"># Ask the next node for its situation</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nextLP</span><span class="o">.</span><span class="n">finishRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msgSent</span> <span class="o">+</span> <span class="n">msgSent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msgRecv</span> <span class="o">+</span> <span class="n">msgRecv</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.checkpoint"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.checkpoint">[docs]</a>    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a checkpoint of the current basesimulator, this function will assume</span>
<span class="sd">        that no messages are still left in the medium, since these are obviously</span>
<span class="sd">        not saved by pickling the base simulator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># pdc = PythonDevs Checkpoint</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CHK_name</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;.pdc&quot;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="c"># If the model was flattened when it was sent to this node, we will also need to flatten it while checkpointing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">flattenConnections</span><span class="p">()</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span><span class="p">:</span>
            <span class="c"># Don&#39;t forget to unflatten!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">unflattenConnections</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.loadCheckpoint"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.loadCheckpoint">[docs]</a>    <span class="k">def</span> <span class="nf">loadCheckpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alert this kernel that it is restoring from a checkpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Overwrite variables for GVT algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitioning</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{}]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">controlmsg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_restored</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setGlobals</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> 
                        <span class="n">loglevel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loglevel</span><span class="p">,</span> 
                        <span class="n">tracers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="p">,</span>
                        <span class="n">memoization</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memoization</span><span class="p">,</span>
                        <span class="n">checkpointname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHK_name</span><span class="p">,</span>
                        <span class="n">checkpointfrequency</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checkpointFreq</span><span class="p">,</span> 
                        <span class="n">statesaver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_saving</span><span class="p">,</span> 
                        <span class="n">kernels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kernels</span><span class="p">,</span>
                        <span class="n">msgCopy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">msgCopy</span><span class="p">)</span>
        <span class="c"># Still unflatten the model if it was flattened (due to pickling limit)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">unflattenConnections</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">msgSent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msgRecv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorevent</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priorlock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="c">#self.inqueue = Queue.Queue()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inqueue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c"># Just perform a revertion</span>
        <span class="c"># but clear the queues first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputQueue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># and the inputQueue, since every model will be reset to GVT</span>
        <span class="c">#  everything that happens before GVT can be cleared by revertion</span>
        <span class="c">#  everything that happens after GVT will be replicated by the external models</span>
        <span class="c"># Useful, since this also allows us to skip saving all this info in the pickled data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputScheduler</span> <span class="o">=</span> <span class="n">MessageScheduler</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">startTracers</span><span class="p">(</span><span class="n">recover</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vlock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">GVT</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseSimulator.simulate_sync"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.simulate_sync">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A small wrapper around the simulate() function, though with a different name to allow a much simpler MPI one way check</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulate</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.simulate"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate at this kernel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Send the init message</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span> <span class="o">==</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">):</span>
            <span class="c"># To make sure that the GVT algorithm won&#39;t start already and see that this</span>
            <span class="c"># model has nothing to simulate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">timeNext</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupledInit</span><span class="p">()</span>
            <span class="c">#assert debug(&quot;Inits sent&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

        <span class="n">controller</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProxy</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runsim</span><span class="p">()</span>
            <span class="c"># Notify that we are currently not doing anything</span>
            <span class="c">#NOTE note that we can NOT shut down the recv channel, as we might receive controller messages</span>
            <span class="c">#assert debug(&quot;Notifying wait&quot;)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">break</span>
            <span class="n">controller</span><span class="o">.</span><span class="n">notifyWait</span><span class="p">()</span>
            <span class="c">#assert debug(&quot;WAIT&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shouldrun</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
                <span class="c"># Simulation has finished</span>
                <span class="c">#assert info(&quot;Simulation finished, halting&quot;)</span>
                <span class="k">break</span>
            <span class="c"># Notify that we are running again</span>
            <span class="c">#assert debug(&quot;WAKE UP&quot;)</span>
            <span class="n">controller</span><span class="o">.</span><span class="n">notifyRun</span><span class="p">()</span>
            <span class="c">#assert debug(&quot;RUN&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simFinish</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="c">#assert info(str(self.name) + &quot; is done&quot;)</span>
        <span class="c">#assert info(&quot;Number of revertions at &quot; + str(self.name) + &quot;: &quot; + str(self.reverts))</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setAttr"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setAttr">[docs]</a>    <span class="k">def</span> <span class="nf">setAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets an attribute of a model.</span>

<span class="sd">        :param model_id: the id of the model to alter</span>
<span class="sd">        :param attr: string representation of the attribute to alter</span>
<span class="sd">        :param value: value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">],</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.setStateAttr"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.setStateAttr">[docs]</a>    <span class="k">def</span> <span class="nf">setStateAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets an attribute of the state of a model</span>

<span class="sd">        :param model_id: the id of the model to alter</span>
<span class="sd">        :param attr: string representation of the attribute to alter</span>
<span class="sd">        :param value: value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.startTracers"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.startTracers">[docs]</a>    <span class="k">def</span> <span class="nf">startTracers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start all tracers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">startTracers</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.stopTracers"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.stopTracers">[docs]</a>    <span class="k">def</span> <span class="nf">stopTracers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stop all tracers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracers</span><span class="o">.</span><span class="n">stopTracers</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getGVT"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getGVT">[docs]</a>    <span class="k">def</span> <span class="nf">getGVT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the GVT of this kernel</span>

<span class="sd">        :returns: float -- the current GVT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GVT</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getTime">[docs]</a>    <span class="k">def</span> <span class="nf">getTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current time of this kernel</span>

<span class="sd">        :returns: float -- the current simulation time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prevtime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getState"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getState">[docs]</a>    <span class="k">def</span> <span class="nf">getState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the state of the specified model</span>

<span class="sd">        :param model_id: the model_id of the model of which the state is requested</span>
<span class="sd">        :returns: state -- the state of the requested model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">state</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getStateAtTime"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getStateAtTime">[docs]</a>    <span class="k">def</span> <span class="nf">getStateAtTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">requestTime</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the state of a model at a specific time</span>

<span class="sd">        :param model_id: model_id of which the state should be fetched</span>
<span class="sd">        :param requestTime: time of the state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_ids</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">getState</span><span class="p">(</span><span class="n">requestTime</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.genUUID"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.genUUID">[docs]</a>    <span class="k">def</span> <span class="nf">genUUID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a unique enough ID for a message</span>

<span class="sd">        :returns: string -- a unique string for the specific name and number of sent messages</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sendmsgcounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sendmsgcounter</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getLocation"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getLocation">[docs]</a>    <span class="k">def</span> <span class="nf">getLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the location at which the model with the provided model_id runs</span>

<span class="sd">        :param model_id: the model_id of the model of which the location is requested</span>
<span class="sd">        :returns: int -- the number of the kernel where the provided model_id runs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fetched</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fetched</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fetched</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getActivity"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getActivity">[docs]</a>    <span class="k">def</span> <span class="nf">getActivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the activity for a certain model id from the previous iteration</span>

<span class="sd">        :param model_id: the model_id to check</span>
<span class="sd">        :returns: float -- the activity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getCompleteActivity"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getCompleteActivity">[docs]</a>    <span class="k">def</span> <span class="nf">getCompleteActivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the complete dictionary of all activities</span>

<span class="sd">        :returns: dict -- mapping of all activities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">activities</span>
</div>
<div class="viewcode-block" id="BaseSimulator.getTotalActivity"><a class="viewcode-back" href="../basesimulator_int.html#basesimulator.BaseSimulator.getTotalActivity">[docs]</a>    <span class="k">def</span> <span class="nf">getTotalActivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">))):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary containing the total activity through the complete simulation run</span>

<span class="sd">        :param time: time up to which to return activity</span>
<span class="sd">        :returns: dict -- mapping of all activities, but simulation-wide</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreversible</span><span class="p">:</span>
            <span class="n">activities</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fetchActivity</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">activities</span><span class="p">)</span>
            <span class="n">addDict</span><span class="p">(</span><span class="n">activities</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalActivities</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">activities</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalActivities</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">PythonPDEVS 2.2.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Yentl Van Tendeloo.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>